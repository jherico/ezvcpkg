import logging
import os
import platform
import re
import sys
import shutil
import tempfile
import subprocess

logger = logging.getLogger('ezvcpkg')

def executeSubprocess(processArgs, folder=None, env=None):
    restoreDir = None
    if folder != None:
        restoreDir = os.getcwd()
        os.chdir(folder)

    process = subprocess.Popen(
        processArgs, stdout=sys.stdout, stderr=sys.stderr, env=env)
    process.wait()

    if (0 != process.returncode):
        raise RuntimeError('Call to "{}" failed.\n\narguments:\n{}\n'.format(
            processArgs[0],
            ' '.join(processArgs[1:]),
            ))

    if restoreDir != None:
        os.chdir(restoreDir)

# Encapsulates the vcpkg system 
class VcpkgRepo:
    CMAKE_TEMPLATE = """
# this file auto-generated by vcpkg_fetch_vcpkg.py
get_filename_component(CMAKE_TOOLCHAIN_FILE "{}" ABSOLUTE CACHE)
get_filename_component(CMAKE_TOOLCHAIN_FILE_UNCACHED "{}" ABSOLUTE)
set(VCPKG_INSTALL_ROOT "{}")
set(VCPKG_TOOLS_DIR "{}")
"""

    CMAKE_TEMPLATE_NON_ANDROID = """
# If the cached cmake toolchain path is different from the computed one, exit
if(NOT (CMAKE_TOOLCHAIN_FILE_UNCACHED STREQUAL CMAKE_TOOLCHAIN_FILE))
    message(FATAL_ERROR "CMAKE_TOOLCHAIN_FILE has changed, please wipe the build directory and rerun cmake")
endif()
"""

    def __init__(self, args):
        self.args = args
        self.id = args.vcpkg_commit
        self.configFilePath = os.path.join(args.build_root, 'vcpkg.cmake')

        # OS dependent information
        system = platform.system()

        if self.args.vcpkg_root is not None:
            self.path = args.vcpkg_root
        else:
            if 'Darwin' == system:
                defaultBasePath = os.path.expanduser('~/hifi/vcpkg')
            else:
                defaultBasePath = os.path.join(tempfile.gettempdir(), 'vcpkg')

            self.basePath = os.getenv('CMAKE_VCPKG_ROOT', defaultBasePath)
            if self.basePath == defaultBasePath:
                logger.warn("Environment variable CMAKE_VCPKG_ROOT not set, using {}".format(defaultBasePath))
            if (not os.path.isdir(self.basePath)):
                os.makedirs(self.basePath)
            self.path = os.path.join(self.basePath, self.id)

        logger.info("Using vcpkg path {}".format(self.path))
        lockDir, lockName = os.path.split(self.path)
        lockName += '.lock'
        if not os.path.isdir(lockDir):
            os.makedirs(lockDir)

        self.lockFile = os.path.join(lockDir, lockName)
        self.tagFile = os.path.join(self.path, '.id')
        # A format version attached to the tag file... increment when you want to force the build systems to rebuild 
        # without the contents of the ports changing
        self.version = 1
        self.tagContents = "{}_{}".format(self.id, self.version)

        if 'Windows' == system:
            self.exe = os.path.join(self.path, 'vcpkg.exe')
            self.bootstrap_script = os.path.join(self.path, 'bootstrap-vcpkg.bat')
        else:
            self.exe = os.path.join(self.path, 'vcpkg')
            self.bootstrap_script = os.path.join(self.path, 'bootstrap-vcpkg.sh')

        # FIXME support more targets, customizing targets from the cmake macro
        if 'Windows' == system:
            self.hostTriplet = 'x64-windows'
        elif 'Darwin' == system:
            self.hostTriplet = 'x64-osx'
        else:
            self.hostTriplet = 'x64-linux'

        self.triplet = self.hostTriplet



    def upToDate(self):
        if self.args.force_build:
            logger.debug("Force build, out of date")
            return False
        if not os.path.isfile(self.exe):
            logger.debug("Exe file {} not found, out of date".format(self.exe))
            return False
        if not os.path.isfile(self.tagFile):
            logger.debug("Tag file {} not found, out of date".format(self.tagFile))
            return False
        with open(self.tagFile, 'r') as f:
            storedTag = f.read()
        if storedTag != self.tagContents:
            logger.debug("Tag file {} contents don't match computed tag {}, out of date".format(self.tagFile, self.tagContents))
            return False
        return True

    def clean(self):
        if os.path.isdir(self.path):
            logger.info("Cleaning vcpkg installation at {}".format(self.path))
            shutil.rmtree(self.path, ignore_errors=True)

    # Make sure the VCPKG prerequisites are all there.
    def bootstrap(self):
        if self.upToDate():
            return

        self.clean()

        downloadVcpkg = False
        if self.args.force_bootstrap:
            logger.info("Forcing bootstrap")
            downloadVcpkg = True

        if not downloadVcpkg and not os.path.isfile(self.exe):
            logger.info("Missing executable, boostrapping")
            downloadVcpkg = True
        
        # Make sure we have a vcpkg executable
        testFile = os.path.join(self.path, '.vcpkg-root')
        if not downloadVcpkg and not os.path.isfile(testFile):
            logger.info("Missing {}, bootstrapping".format(testFile))
            downloadVcpkg = True

        if downloadVcpkg:
            logger.info("Cloning vcpkg from {} to {}".format(self.args.vcpkg_url, self.path))
            executeSubprocess(['git', 'clone', self.args.vcpkg_url, self.path])
            logger.info("Checking out commit {}".format(self.args.vcpkg_commit))
            executeSubprocess(['git', 'checkout', self.args.vcpkg_commit], folder=self.path)
            logger.info("Building vcpkg")
            executeSubprocess([self.bootstrap_script], folder=self.path)

    def run(self, commands):
        actualCommands = [self.exe, '--vcpkg-root', self.path]
        actualCommands.extend(commands)
        logger.debug("Running command")
        logger.debug(actualCommands)
        executeSubprocess(actualCommands, folder=self.path)

    def setupDependencies(self):
        logger.info("Installing packages: {}".format(','.join(self.args.vcpkg_packages)))
        commands = ['install', '--triplet', self.hostTriplet ]
        commands.extend(self.args.vcpkg_packages)
        self.run(commands)

    def cleanBuilds(self):
        # Remove temporary build artifacts
        builddir = os.path.join(self.path, 'buildtrees')
        if os.path.isdir(builddir):
            logger.info("Wiping build trees")
            shutil.rmtree(builddir, ignore_errors=True)

    def writeTag(self):
        logger.info("Writing tag {} to {}".format(self.tagContents, self.tagFile))
        with open(self.tagFile, 'w') as f:
            f.write(self.tagContents)

    def writeConfig(self):
        logger.info("Writing cmake config to {}".format(self.configFilePath))
        # Write out the configuration for use by CMake
        cmakeScript = os.path.join(self.path, 'scripts/buildsystems/vcpkg.cmake')
        installPath = os.path.join(self.path, 'installed', self.triplet)
        toolsPath = os.path.join(self.path, 'installed', self.hostTriplet, 'tools')
        cmakeTemplate = VcpkgRepo.CMAKE_TEMPLATE
        cmakeTemplate += VcpkgRepo.CMAKE_TEMPLATE_NON_ANDROID
        cmakeConfig = cmakeTemplate.format(cmakeScript, cmakeScript, installPath, toolsPath).replace('\\', '/')
        with open(self.configFilePath, 'w') as f:
            f.write(cmakeConfig)

    def cleanOldBuilds(self):
        # If the vcpkg location was explicitly specified, don't do any cleaning
        if (self.args.vcpkg_root):
            return

        # FIXME because we have the base directory, and because a build will 
        # update the tag file on every run, we can scan the base dir for sub directories containing 
        # a tag file that is older than N days, and if found, delete the directory, recovering space
        logger.warn("Not implemented")
